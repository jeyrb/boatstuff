#!/bin/bash

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INSTALL]${NC} $1"
}

log_error() {
    echo -e "${RED}[INSTALL]${NC} $1"
}

# Check if we're in a git repository
if [[ ! -d ".git" ]]; then
    log_error "Not in a git repository"
    exit 1
fi

# Git pre-commit hook to sync files from external sources
# Based on configuration in .sync-config.json

SIMPLE_CONFIG=".sync-files.txt"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[SYNC]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[SYNC]${NC} $1"
}

log_error() {
    echo -e "${RED}[SYNC]${NC} $1"
}

# Function to expand tilde in paths
expand_path() {
    local path="$1"
    echo "${path/#\~/$HOME}"
}

sync_file() {
    local source="$1"
    local destination="$2"
    local files_changed=false
    
    if [[ ! -f "$source" ]]; then
        log_warn "Source file not found: $source"
        return 1
    fi
    
    # Create destination directory if it doesn't exist
    mkdir -p "$(dirname "$destination")"
    
    # Copy file if it's different or doesn't exist
    if [[ ! -f "$destination" ]] || ! cmp -s "$source" "$destination"; then
        cp "$source" "$destination"
        git add "$destination"
        log_info "Updated file: $destination"
        return 0  # Changed
    else
        log_info "No changes: $destination"
        return 2  # No change
    fi
}

# Function to sync a directory
sync_directory() {
    local source="$1"
    local destination="$2"
    local files_changed=false
    
    if [[ ! -d "$source" ]]; then
        log_warn "Source directory not found: $source"
        return 1
    fi
    
    # Create destination directory
    mkdir -p "$(dirname "$destination")"
    
    zip_output=$(zip -r --filesync "$destination" "$source"  2>&1)
    local zip_exit=$?
    
    if [[ $zip_exit -eq 0 ]]; then
        log_info "Zipped: $destination"
	git add $destination
        return 0  # Changed
    else
        log_error "Failed to zip directory: $source -> $destination"
        log_error "zip output: $zip_output"
        return 1
    fi
}

# Function to sync files from simple text config
sync_from_text() {
    local files_changed=false
    
    while IFS=':' read -r source destination type_and_excludes; do
        # Skip empty lines and comments
        [[ -z "$source" || "$source" =~ ^[[:space:]]*# ]] && continue
        
        # Trim whitespace
        source=$(echo "$source" | xargs)
        destination=$(echo "$destination" | xargs)
        
        # Parse type and exclude patterns
        local type="auto"
        local exclude_patterns=()
        
        if [[ -n "$type_and_excludes" ]]; then
            # Split by comma to get type and exclude patterns
            IFS=',' read -ra parts <<< "$type_and_excludes"
            for part in "${parts[@]}"; do
                part=$(echo "$part" | xargs)  # Trim whitespace
                if [[ "$part" == "file" || "$part" == "directory" || "$part" == "auto" ]]; then
                    type="$part"
                elif [[ "$part" == exclude=* ]]; then
                    exclude_patterns+=("${part#exclude=}")
                fi
            done
        fi
        
        # Expand tilde in source path
        source=$(expand_path "$source")
        
        log_info "Processing: $source -> $destination (type: $type)"
        
        # Determine type automatically if not specified
        if [[ "$type" == "auto" ]]; then
            if [[ -f "$source" ]]; then
                type="file"
            elif [[ -d "$source" ]]; then
                type="directory"
            else
                log_warn "Source not found: $source"
                continue
            fi
        fi
        
        # Sync based on type
        case "$type" in
            "file")
                if sync_file "$source" "$destination"; then
                    files_changed=true
                fi
                ;;
            "directory")
                if sync_directory "$source" "$destination" "${exclude_patterns[@]}"; then
                    files_changed=true
                fi
                ;;
            *)
                log_warn "Unknown sync type '$type' for: $source"
                ;;
        esac
        
    done < "$SIMPLE_CONFIG"
    
    if $files_changed; then
        log_info "Files have been updated and staged for commit"
    else
        log_info "All files are up to date"
    fi
}

# Main execution
main() {
    log_info "Starting file sync process..."
    
    if [[ -f "$SIMPLE_CONFIG" ]]; then
        sync_from_text
    else
        log_warn "No sync configuration found"
        exit 0
    fi
}

main
exit 0
EOF
    
    chmod +x "$HOOKS_DIR/pre-commit"
    log_info "Created and installed pre-commit hook"
fi

log_info "Hook installation complete!"
log_info "The pre-commit hook will now sync files before each commit based on your config file."

